#-------------------------------------------------------------------------------
# Name:        ServerSTM
# Purpose:     Defines the behavior of the server
# Author:      The Internet
# Editor:      M
# Created:     01/26/2014
#-------------------------------------------------------------------------------
# StateMachine/TramControl.py
# Autonomous and directed control of tram operation
import string, sys, time
import subprocess 
sys.path += [".\lib"]
from ctypes import *
from State import State
from StateMachine import StateMachine
from TramAction import TramAction
from socket import error as SocketError

class StateT(State):
    def __init__(self):
        self.transitions = None
    def next(self, input):
        if(input in self.transitions):
            return self.transitions[input]
        else:
            print ("Input %s not supported for current state" % input)
            return self

class Wait(StateT):
    def run(self, serv,accel,meas):
        print("Tram: Waiting for command from Base Station")
        if accel.Data[0] < (accel.Stats[0] - 2.5*accel.Stats[3]) and accel.Data[0] > (accel.Stats[0] + 2.5*accel.Stats[3]) or accel.Data[1] < (accel.Stats[1] - 2.5*accel.Stats[4]) or accel.Data[1] > (accel.Stats[1] + 2.5*accel.Stats[4]) or accel.Data[2] < (accel.Stats[2] - 2.5*accel.Stats[5]) or accel.Data[2] > (accel.Stats[2] + 2.5*accel.Stats[5]) :
	   serv.dataT[0]=(str("emergency"))
           serv.data = map(TramAction, serv.dataT)

    def next(self,input):
        # Supported transition initialization:
        if not self.transitions:
            self.transitions = {
                TramAction.wait : TramControl.wait,
                TramAction.measure : TramControl.measure,
                TramAction.emergency : TramControl.emergency,
                TramAction.picture : TramControl.picture
           }
        return StateT.next(self, input)

class Measure(StateT):
    def run(self,serv,accel,meas):
        print("Tram: Measuring")
        if meas.busy==0 :
           meas.takeMeasurements(1,1,0,0,0)
           meas.busy = 1

	if meas.takePic == 1 and (meas.a == None or meas.a.poll() != None) and (meas.b == None or meas.b.poll() != None) and meas.busy == 1 :
           meas.takeMeasurements(0,0,0,0,0)
           meas.busy = 2
        else :
             if (meas.a == None or meas.a.poll() != None) and (meas.b == None or meas.b.poll() != None) and meas.takePic == 0 :
                meas.busy=2

        if meas.busy == 2 and (meas.c == None or meas.c.poll() != None) :
           meas.busy=0
           try:
               serv.connInfo[0].send('done')
           except SocketError as e:
                  pass
	   serv.dataT[0]=(str("wait"))
           serv.data = map(TramAction, serv.dataT)

        if accel.Data[0] < (accel.Stats[0] - 2.5*accel.Stats[3]) or accel.Data[0] > (accel.Stats[0] + 2.5*accel.Stats[3]) or accel.Data[1] < (accel.Stats[1] - 2.5*accel.Stats[4]) or accel.Data[1] > (accel.Stats[1] + 2.5*accel.Stats[4]) or accel.Data[2] < (accel.Stats[2] - 2.5*accel.Stats[5]) or accel.Data[2] > (accel.Stats[2] + 2.5*accel.Stats[5]) :
	    serv.dataT[0]=(str("emergency"))
            serv.data = map(TramAction, serv.dataT)

    def next(self, input):
        # Supported transition initialization:
        if not self.transitions:
            self.transitions = {
                TramAction.wait : TramControl.wait,
                TramAction.measure : TramControl.measure,
                TramAction.emergency : TramControl.emergency,
                TramAction.picture : TramControl.picture
            }
        return StateT.next(self, input)

class Picture(StateT):
    def run(self,serv,accel,meas):
        print("Tram: Streaming Video")
        if meas.busy == 0 :
           meas.takeMeasurements(0,0,0,1,0)

	if meas.busy == 1 and meas.d.poll() != None :
           meas.busy=0
           try:
               serv.connInfo[0].send('done')
	   except SocketError as e:
                   pass
	   serv.dataT[0]=(str("wait"))
           serv.data = map(TramAction, serv.dataT)
       
        if accel.Data[0] < (accel.Stats[0] - 2.5*accel.Stats[3]) or accel.Data[0] > (accel.Stats[0] + 2.5*accel.Stats[3]) or accel.Data[1] < (accel.Stats[1] - 2.5*accel.Stats[4]) or accel.Data[1] > (accel.Stats[1] + 2.5*accel.Stats[4]) or accel.Data[2] < (accel.Stats[2] - 2.5*accel.Stats[5]) or accel.Data[2] > (accel.Stats[2] + 2.5*accel.Stats[5]) :
	   serv.dataT[0]=(str("emergency"))
           serv.data = map(TramAction, serv.dataT)

    def next(self, input):
        # Supported transition initialization:
        if not self.transitions:
            self.transitions = {
                TramAction.wait : TramControl.wait,
                TramAction.measure : TramControl.measure,
                TramAction.emergency : TramControl.emergency,
                TramAction.picture : TramControl.picture
            }
        return StateT.next(self, input)

class Emergency(StateT):
    def run(self,serv,accel,meas):
        print("Tram in Emergency state")
        if accel.Data[0] < (accel.Stats[0] - 2.5*accel.Stats[3]) or accel.Data[0] > (accel.Stats[0] + 2.5*accel.Stats[3]) or accel.Data[1] < (accel.Stats[1] - 2.5*accel.Stats[4]) or accel.Data[1] > (accel.Stats[1] + 2.5*accel.Stats[4]) or accel.Data[2] < (accel.Stats[2] - 2.5*accel.Stats[5]) or accel.Data[2] > (accel.Stats[2] + 2.5*accel.Stats[5]) :
            accel.Danger[0] = accel.Danger[0] + 1
            if accel.Danger[0] == 1000 :
               if serv.connInfo[0] != None :
                  try: 
                      serv.connInfo[0].send('help')
                  except SocketError as e:
                         pass
               accel.Danger[0] = 0
               accel.Danger[1] = accel.Danger[1] + 1
        else:
            if accel.Danger[1] > 1000 and (accel.Data[0] < (accel.Stats[0] - 5*accel.Stats[3]) or accel.Data[0] > (accel.Stats[0] + 5*accel.Stats[3]) or accel.Data[1] < (accel.Stats[1] - 5*accel.Stats[4]) or accel.Data[1] > (accel.Stats[1] + 5*accel.Stats[4]) or accel.Data[2] < (accel.Stats[2] - 5*accel.Stats[5]) or accel.Data[2] > (accel.Stats[2] + 5*accel.Stats[5])) :
	       serv.dataT[0]=(str("shutdown"))
               serv.data = map(TramAction, serv.dataT)
            else:
                if accel.Data[0] > (accel.Stats[0] - 2.5*accel.Stats[3]) and accel.Data[0] < (accel.Stats[0] + 2.5*accel.Stats[3]) and accel.Data[1] > (accel.Stats[1] - 2.5*accel.Stats[4]) and accel.Data[1] < (accel.Stats[1] + 2.5*accel.Stats[4]) and accel.Data[2] > (accel.Stats[2] - 2.5*accel.Stats[5]) and accel.Data[2] < (accel.Stats[2] + 2.5*accel.Stats[5]) :
                   serv.dataT[0]=(str("wait"))
                   serv.data = map(TramAction, serv.dataT)

    def next(self, input):
        # Supported transition initialization:
        if not self.transitions:
            self.transitions = {
                TramAction.wait : TramControl.wait,
                TramAction.measure : TramControl.measure,
                TramAction.emergency : TramControl.emergency,
                TramAction.picture : TramControl.picture,
                TramAction.shutdown : TramControl.shutdown
             }
        return StateT.next(self, input)

class Shutdown(StateT):
    def run(self,serv,accel,meas):
        print("Tram shutting down")
        try:
            serv.connInfo[0].send('shutdown')
        except SocketError as e:
               pass
    def next(self, input):
	# Supported transition initialization:
        if not self.transitions:
            self.transitions = {
                TramAction.wait : TramControl.wait,
                TramAction.emergency : TramControl.emergency,
                TramAction.shutdown : TramControl.shutdown
            }
        return StateT.next(self, input)
    
class TramControl(StateMachine):
    def __init__(self):
        # Initial state
        StateMachine.__init__(self, TramControl.wait)

def main():
    pass


if __name__ == '__main__':

    main()
    TramControl.wait = Wait()
    TramControl.measure = Measure()
    TramControl.picture = Picture()
    TramControl.emergency= Emergency()
    TramControl.shutdown= Shutdown()
  
    
   
    TramControl().runAll()   



